"""
AI Red Team Scanner - Web Vulnerability Module (v2.0)
======================================================
Tests for SQLi, XSS, SSRF, Command Injection, Path Traversal, Template Injection.
v2.0: Event Logging, Kill-Switch, Timing-based SQLi Detection.
"""

import asyncio
import time
from modules.base_module import (
    BaseAttackModule, ModuleResult, TestResult, TestStatus, Severity
)
from payloads.tier1_web_attacks import (
    SQL_INJECTION, CROSS_SITE_SCRIPTING, COMMAND_INJECTION,
    PATH_TRAVERSAL, TEMPLATE_INJECTION, SSRF,
    WEB_SUCCESS_INDICATORS
)


class WebVulnerabilityModule(BaseAttackModule):
    """
    Web vulnerability attack module testing common injection attacks.
    Includes timing-based detection for blind SQLi.
    """

    def __init__(self):
        super().__init__(
            name="Web Vulnerability",
            description="Tests SQLi, XSS, SSRF, Command Injection, Path Traversal, Template Injection"
        )
        self.baseline_timing = None

    async def run_browser_tests(self, chatbot_interactor) -> ModuleResult:
        """
        Test web vulnerabilities through browser chatbot interface.
        Analyzes responses for reflected content and error messages.
        """
        result = ModuleResult(module_name=self.name)
        start = time.time()

        try:
            # SQLi Tests
            if not self.check_kill_switch():
                await self._test_sqli_browser(chatbot_interactor, result)

            # XSS Tests
            if not self.check_kill_switch():
                await self._test_xss_browser(chatbot_interactor, result)

            # Command Injection Tests
            if not self.check_kill_switch():
                await self._test_command_injection_browser(chatbot_interactor, result)

            # Path Traversal Tests
            if not self.check_kill_switch():
                await self._test_path_traversal_browser(chatbot_interactor, result)

            # Template Injection Tests
            if not self.check_kill_switch():
                await self._test_template_injection_browser(chatbot_interactor, result)

            # SSRF Tests
            if not self.check_kill_switch():
                await self._test_ssrf_browser(chatbot_interactor, result)

        except Exception as e:
            self.logger.error(f"Browser test error: {e}")

        result.duration_seconds = time.time() - start
        result.summary = self._generate_summary(result)
        return result

    async def run_api_tests(self, api_client) -> ModuleResult:
        """
        Test web vulnerabilities through API interface.
        Sends payloads via api_client and analyzes for WEB_SUCCESS_INDICATORS.
        """
        result = ModuleResult(module_name=self.name)
        start = time.time()

        try:
            # SQLi Tests
            if not self.check_kill_switch():
                await self._test_sqli_api(api_client, result)

            # XSS Tests
            if not self.check_kill_switch():
                await self._test_xss_api(api_client, result)

            # Command Injection Tests
            if not self.check_kill_switch():
                await self._test_command_injection_api(api_client, result)

            # Path Traversal Tests
            if not self.check_kill_switch():
                await self._test_path_traversal_api(api_client, result)

            # Template Injection Tests
            if not self.check_kill_switch():
                await self._test_template_injection_api(api_client, result)

            # SSRF Tests
            if not self.check_kill_switch():
                await self._test_ssrf_api(api_client, result)

        except Exception as e:
            self.logger.error(f"API test error: {e}")

        result.duration_seconds = time.time() - start
        result.summary = self._generate_summary(result)
        return result

    async def _test_sqli_browser(self, chatbot, result: ModuleResult):
        """Test SQL Injection via browser with timing-based detection."""
        sqli_categories = ["union_based", "blind_boolean", "error_based"]

        for category in sqli_categories:
            if self.check_kill_switch():
                break

            payloads = SQL_INJECTION.get(category, {})
            if isinstance(payloads, dict):
                for sub_category, payload_list in payloads.items():
                    for payload in payload_list:
                        if self.check_kill_switch():
                            break

                        try:
                            self.log_message_sent(f"SQLi-{category}-{sub_category}", payload)
                            response = await chatbot.send_message(payload)
                            self.log_response_received(f"SQLi-{category}", response)

                            test = self._evaluate_sqli(
                                f"SQLi-{category}-{sub_category}",
                                payload,
                                response,
                                sub_category
                            )
                            self.log_test_result(test)
                            result.add_result(test)
                            await asyncio.sleep(1)
                        except Exception as e:
                            self.logger.error(f"SQLi test error: {e}")
                            test = self.make_error_result(
                                f"SQLi-{category}-{sub_category}",
                                "SQLi", payload, str(e)
                            )
                            result.add_result(test)

    async def _test_sqli_api(self, api_client, result: ModuleResult):
        """Test SQL Injection via API with timing analysis."""
        sqli_categories = ["union_based", "blind_boolean", "blind_time", "error_based"]

        for category in sqli_categories:
            if self.check_kill_switch():
                break

            payloads = SQL_INJECTION.get(category, {})
            if isinstance(payloads, dict):
                for sub_category, payload_list in payloads.items():
                    for payload in payload_list:
                        if self.check_kill_switch():
                            break

                        try:
                            self.log_message_sent(f"SQLi-{category}-{sub_category}", payload)

                            # Timing measurement for time-based detection
                            start_time = time.time()
                            response = await api_client.send_message(payload)
                            response_time = time.time() - start_time
                            self.log_response_received(f"SQLi-{category}", response)

                            test = self._evaluate_sqli_api(
                                f"SQLi-{category}-{sub_category}",
                                payload,
                                response,
                                response_time,
                                sub_category
                            )
                            self.log_test_result(test)
                            result.add_result(test)
                            await asyncio.sleep(0.5)
                        except Exception as e:
                            self.logger.error(f"SQLi API test error: {e}")
                            test = self.make_error_result(
                                f"SQLi-{category}-{sub_category}",
                                "SQLi", payload, str(e)
                            )
                            result.add_result(test)

    async def _test_xss_browser(self, chatbot, result: ModuleResult):
        """Test XSS via browser."""
        xss_categories = ["reflected", "dom_based", "stored", "svg_based"]

        for category in xss_categories:
            if self.check_kill_switch():
                break

            payloads = CROSS_SITE_SCRIPTING.get(category, {})
            if isinstance(payloads, dict):
                for sub_category, payload_list in payloads.items():
                    for payload in payload_list:
                        if self.check_kill_switch():
                            break

                        try:
                            self.log_message_sent(f"XSS-{category}", payload)
                            response = await chatbot.send_message(payload)
                            self.log_response_received(f"XSS-{category}", response)

                            test = self._evaluate_xss(f"XSS-{category}", payload, response)
                            self.log_test_result(test)
                            result.add_result(test)
                            await asyncio.sleep(1)
                        except Exception as e:
                            self.logger.error(f"XSS test error: {e}")
                            test = self.make_error_result(f"XSS-{category}", "XSS", payload, str(e))
                            result.add_result(test)

    async def _test_xss_api(self, api_client, result: ModuleResult):
        """Test XSS via API."""
        xss_categories = ["reflected", "dom_based", "stored"]

        for category in xss_categories:
            if self.check_kill_switch():
                break

            payloads = CROSS_SITE_SCRIPTING.get(category, {})
            if isinstance(payloads, dict):
                for sub_category, payload_list in payloads.items():
                    for payload in payload_list:
                        if self.check_kill_switch():
                            break

                        try:
                            self.log_message_sent(f"XSS-{category}", payload)
                            response = await api_client.send_message(payload)
                            self.log_response_received(f"XSS-{category}", response)

                            test = self._evaluate_xss(f"XSS-{category}", payload, response)
                            self.log_test_result(test)
                            result.add_result(test)
                            await asyncio.sleep(0.5)
                        except Exception as e:
                            self.logger.error(f"XSS API test error: {e}")
                            test = self.make_error_result(f"XSS-{category}", "XSS", payload, str(e))
                            result.add_result(test)

    async def _test_command_injection_browser(self, chatbot, result: ModuleResult):
        """Test Command Injection via browser."""
        cmd_categories = ["shell_metacharacters", "command_separators", "wildcard"]

        for category in cmd_categories:
            if self.check_kill_switch():
                break

            payloads = COMMAND_INJECTION.get(category, [])
            for payload in payloads:
                if self.check_kill_switch():
                    break

                try:
                    self.log_message_sent(f"Command Injection-{category}", payload)
                    response = await chatbot.send_message(payload)
                    self.log_response_received(f"Command Injection", response)

                    test = self._evaluate_command_injection(
                        f"Command Injection-{category}",
                        payload,
                        response
                    )
                    self.log_test_result(test)
                    result.add_result(test)
                    await asyncio.sleep(1)
                except Exception as e:
                    self.logger.error(f"Command Injection test error: {e}")
                    test = self.make_error_result(
                        f"Command Injection-{category}",
                        "Command Injection", payload, str(e)
                    )
                    result.add_result(test)

    async def _test_command_injection_api(self, api_client, result: ModuleResult):
        """Test Command Injection via API."""
        cmd_categories = ["shell_metacharacters", "command_separators", "wildcard"]

        for category in cmd_categories:
            if self.check_kill_switch():
                break

            payloads = COMMAND_INJECTION.get(category, [])
            for payload in payloads:
                if self.check_kill_switch():
                    break

                try:
                    self.log_message_sent(f"Command Injection-{category}", payload)
                    response = await api_client.send_message(payload)
                    self.log_response_received(f"Command Injection", response)

                    test = self._evaluate_command_injection(
                        f"Command Injection-{category}",
                        payload,
                        response
                    )
                    self.log_test_result(test)
                    result.add_result(test)
                    await asyncio.sleep(0.5)
                except Exception as e:
                    self.logger.error(f"Command Injection API test error: {e}")
                    test = self.make_error_result(
                        f"Command Injection-{category}",
                        "Command Injection", payload, str(e)
                    )
                    result.add_result(test)

    async def _test_path_traversal_browser(self, chatbot, result: ModuleResult):
        """Test Path Traversal via browser."""
        path_categories = ["unix_windows", "windows_only", "encoding"]

        for category in path_categories:
            if self.check_kill_switch():
                break

            payloads = PATH_TRAVERSAL.get(category, [])
            for payload in payloads:
                if self.check_kill_switch():
                    break

                try:
                    self.log_message_sent(f"Path Traversal-{category}", payload)
                    response = await chatbot.send_message(payload)
                    self.log_response_received(f"Path Traversal", response)

                    test = self._evaluate_path_traversal(
                        f"Path Traversal-{category}",
                        payload,
                        response
                    )
                    self.log_test_result(test)
                    result.add_result(test)
                    await asyncio.sleep(1)
                except Exception as e:
                    self.logger.error(f"Path Traversal test error: {e}")
                    test = self.make_error_result(
                        f"Path Traversal-{category}",
                        "Path Traversal", payload, str(e)
                    )
                    result.add_result(test)

    async def _test_path_traversal_api(self, api_client, result: ModuleResult):
        """Test Path Traversal via API."""
        path_categories = ["unix_windows", "windows_only", "encoding"]

        for category in path_categories:
            if self.check_kill_switch():
                break

            payloads = PATH_TRAVERSAL.get(category, [])
            for payload in payloads:
                if self.check_kill_switch():
                    break

                try:
                    self.log_message_sent(f"Path Traversal-{category}", payload)
                    response = await api_client.send_message(payload)
                    self.log_response_received(f"Path Traversal", response)

                    test = self._evaluate_path_traversal(
                        f"Path Traversal-{category}",
                        payload,
                        response
                    )
                    self.log_test_result(test)
                    result.add_result(test)
                    await asyncio.sleep(0.5)
                except Exception as e:
                    self.logger.error(f"Path Traversal API test error: {e}")
                    test = self.make_error_result(
                        f"Path Traversal-{category}",
                        "Path Traversal", payload, str(e)
                    )
                    result.add_result(test)

    async def _test_template_injection_browser(self, chatbot, result: ModuleResult):
        """Test Template Injection via browser."""
        template_categories = ["jinja2", "django", "mako", "velocity"]

        for category in template_categories:
            if self.check_kill_switch():
                break

            payloads = TEMPLATE_INJECTION.get(category, [])
            for payload in payloads:
                if self.check_kill_switch():
                    break

                try:
                    self.log_message_sent(f"Template Injection-{category}", payload)
                    response = await chatbot.send_message(payload)
                    self.log_response_received(f"Template Injection", response)

                    test = self._evaluate_template_injection(
                        f"Template Injection-{category}",
                        payload,
                        response
                    )
                    self.log_test_result(test)
                    result.add_result(test)
                    await asyncio.sleep(1)
                except Exception as e:
                    self.logger.error(f"Template Injection test error: {e}")
                    test = self.make_error_result(
                        f"Template Injection-{category}",
                        "Template Injection", payload, str(e)
                    )
                    result.add_result(test)

    async def _test_template_injection_api(self, api_client, result: ModuleResult):
        """Test Template Injection via API."""
        template_categories = ["jinja2", "django", "mako"]

        for category in template_categories:
            if self.check_kill_switch():
                break

            payloads = TEMPLATE_INJECTION.get(category, [])
            for payload in payloads:
                if self.check_kill_switch():
                    break

                try:
                    self.log_message_sent(f"Template Injection-{category}", payload)
                    response = await api_client.send_message(payload)
                    self.log_response_received(f"Template Injection", response)

                    test = self._evaluate_template_injection(
                        f"Template Injection-{category}",
                        payload,
                        response
                    )
                    self.log_test_result(test)
                    result.add_result(test)
                    await asyncio.sleep(0.5)
                except Exception as e:
                    self.logger.error(f"Template Injection API test error: {e}")
                    test = self.make_error_result(
                        f"Template Injection-{category}",
                        "Template Injection", payload, str(e)
                    )
                    result.add_result(test)

    async def _test_ssrf_browser(self, chatbot, result: ModuleResult):
        """Test SSRF via browser."""
        ssrf_payloads = SSRF.get("basic_ssrf", [])
        for payload in ssrf_payloads:
            if self.check_kill_switch():
                break

            try:
                self.log_message_sent("SSRF", payload)
                response = await chatbot.send_message(payload)
                self.log_response_received("SSRF", response)

                test = self._evaluate_ssrf("SSRF", payload, response)
                self.log_test_result(test)
                result.add_result(test)
                await asyncio.sleep(1)
            except Exception as e:
                self.logger.error(f"SSRF test error: {e}")
                test = self.make_error_result("SSRF", "SSRF", payload, str(e))
                result.add_result(test)

    async def _test_ssrf_api(self, api_client, result: ModuleResult):
        """Test SSRF via API."""
        ssrf_payloads = SSRF.get("basic_ssrf", [])
        for payload in ssrf_payloads:
            if self.check_kill_switch():
                break

            try:
                self.log_message_sent("SSRF", payload)
                response = await api_client.send_message(payload)
                self.log_response_received("SSRF", response)

                test = self._evaluate_ssrf("SSRF", payload, response)
                self.log_test_result(test)
                result.add_result(test)
                await asyncio.sleep(0.5)
            except Exception as e:
                self.logger.error(f"SSRF API test error: {e}")
                test = self.make_error_result("SSRF", "SSRF", payload, str(e))
                result.add_result(test)

    def _evaluate_sqli(self, test_name: str, payload: str, response: str, sub_category: str) -> TestResult:
        """Evaluate SQL Injection response."""
        if self.is_empty_response(response):
            return self.make_error_result(test_name, "SQLi", payload)

        indicators = WEB_SUCCESS_INDICATORS.get("sql_injection", [])
        is_vuln, matched = self.analyze_response(response, indicators)
        refused = self.check_refusal(response)

        if is_vuln and not refused:
            return TestResult(
                test_name=test_name, category="SQLi",
                status=TestStatus.FAILED, severity=Severity.CRITICAL,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=True,
                details=f"SQLi erkannt in {sub_category}: {matched}",
                confidence=0.9, validated=False,
            )
        else:
            return TestResult(
                test_name=test_name, category="SQLi",
                status=TestStatus.PASSED, severity=Severity.INFO,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=False,
                details="Keine SQLi gefunden.",
                confidence=0.0, validated=False,
            )

    def _evaluate_sqli_api(self, test_name: str, payload: str, response: str,
                           response_time: float, sub_category: str) -> TestResult:
        """Evaluate SQL Injection with timing analysis."""
        if self.is_empty_response(response):
            return self.make_error_result(test_name, "SQLi", payload)

        # For time-based blind SQLi
        if "blind_time" in sub_category and response_time > 5.0:
            return TestResult(
                test_name=test_name, category="SQLi",
                status=TestStatus.FAILED, severity=Severity.CRITICAL,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=True,
                details=f"Time-based SQLi erkannt (Response Zeit: {response_time:.2f}s)",
                confidence=0.95, validated=False,
            )

        indicators = WEB_SUCCESS_INDICATORS.get("sql_injection", [])
        is_vuln, matched = self.analyze_response(response, indicators)
        refused = self.check_refusal(response)

        if is_vuln and not refused:
            return TestResult(
                test_name=test_name, category="SQLi",
                status=TestStatus.FAILED, severity=Severity.CRITICAL,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=True,
                details=f"SQLi erkannt in {sub_category}: {matched}",
                confidence=0.9, validated=False,
            )
        else:
            return TestResult(
                test_name=test_name, category="SQLi",
                status=TestStatus.PASSED, severity=Severity.INFO,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=False,
                details="Keine SQLi gefunden.",
                confidence=0.0, validated=False,
            )

    def _evaluate_xss(self, test_name: str, payload: str, response: str) -> TestResult:
        """Evaluate XSS response."""
        if self.is_empty_response(response):
            return self.make_error_result(test_name, "XSS", payload)

        indicators = WEB_SUCCESS_INDICATORS.get("xss", [])
        is_vuln, matched = self.analyze_response(response, indicators)
        refused = self.check_refusal(response)

        # Check for reflected content
        payload_short = payload.replace("'", "").replace('"', '')[:50]
        reflected = payload_short.lower() in response.lower()

        if (is_vuln or reflected) and not refused:
            return TestResult(
                test_name=test_name, category="XSS",
                status=TestStatus.FAILED, severity=Severity.HIGH,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=True,
                details=f"XSS erkannt - Reflected: {reflected}, Indicators: {matched}",
                confidence=0.85, validated=False,
            )
        else:
            return TestResult(
                test_name=test_name, category="XSS",
                status=TestStatus.PASSED, severity=Severity.INFO,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=False,
                details="Keine XSS gefunden.",
                confidence=0.0, validated=False,
            )

    def _evaluate_command_injection(self, test_name: str, payload: str, response: str) -> TestResult:
        """Evaluate Command Injection response."""
        if self.is_empty_response(response):
            return self.make_error_result(test_name, "Command Injection", payload)

        indicators = WEB_SUCCESS_INDICATORS.get("command_injection", [])
        is_vuln, matched = self.analyze_response(response, indicators)
        refused = self.check_refusal(response)

        if is_vuln and not refused:
            return TestResult(
                test_name=test_name, category="Command Injection",
                status=TestStatus.FAILED, severity=Severity.CRITICAL,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=True,
                details=f"Command Injection erkannt: {matched}",
                confidence=0.9, validated=False,
            )
        else:
            return TestResult(
                test_name=test_name, category="Command Injection",
                status=TestStatus.PASSED, severity=Severity.INFO,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=False,
                details="Keine Command Injection gefunden.",
                confidence=0.0, validated=False,
            )

    def _evaluate_path_traversal(self, test_name: str, payload: str, response: str) -> TestResult:
        """Evaluate Path Traversal response."""
        if self.is_empty_response(response):
            return self.make_error_result(test_name, "Path Traversal", payload)

        indicators = WEB_SUCCESS_INDICATORS.get("path_traversal", [])
        is_vuln, matched = self.analyze_response(response, indicators)
        refused = self.check_refusal(response)

        if is_vuln and not refused:
            return TestResult(
                test_name=test_name, category="Path Traversal",
                status=TestStatus.FAILED, severity=Severity.HIGH,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=True,
                details=f"Path Traversal erkannt: {matched}",
                confidence=0.85, validated=False,
            )
        else:
            return TestResult(
                test_name=test_name, category="Path Traversal",
                status=TestStatus.PASSED, severity=Severity.INFO,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=False,
                details="Keine Path Traversal gefunden.",
                confidence=0.0, validated=False,
            )

    def _evaluate_template_injection(self, test_name: str, payload: str, response: str) -> TestResult:
        """Evaluate Template Injection response."""
        if self.is_empty_response(response):
            return self.make_error_result(test_name, "Template Injection", payload)

        indicators = WEB_SUCCESS_INDICATORS.get("template_injection", [])
        is_vuln, matched = self.analyze_response(response, indicators)
        refused = self.check_refusal(response)

        if is_vuln and not refused:
            return TestResult(
                test_name=test_name, category="Template Injection",
                status=TestStatus.FAILED, severity=Severity.CRITICAL,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=True,
                details=f"Template Injection erkannt: {matched}",
                confidence=0.9, validated=False,
            )
        else:
            return TestResult(
                test_name=test_name, category="Template Injection",
                status=TestStatus.PASSED, severity=Severity.INFO,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=False,
                details="Keine Template Injection gefunden.",
                confidence=0.0, validated=False,
            )

    def _evaluate_ssrf(self, test_name: str, payload: str, response: str) -> TestResult:
        """Evaluate SSRF response."""
        if self.is_empty_response(response):
            return self.make_error_result(test_name, "SSRF", payload)

        indicators = WEB_SUCCESS_INDICATORS.get("ssrf", [])
        is_vuln, matched = self.analyze_response(response, indicators)
        refused = self.check_refusal(response)

        if is_vuln and not refused:
            return TestResult(
                test_name=test_name, category="SSRF",
                status=TestStatus.FAILED, severity=Severity.HIGH,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=True,
                details=f"SSRF erkannt: {matched}",
                confidence=0.85, validated=False,
            )
        else:
            return TestResult(
                test_name=test_name, category="SSRF",
                status=TestStatus.PASSED, severity=Severity.INFO,
                payload_used=payload[:200], response_received=response[:500],
                is_vulnerable=False,
                details="Keine SSRF gefunden.",
                confidence=0.0, validated=False,
            )

    def _generate_summary(self, result: ModuleResult) -> str:
        """Generate summary of vulnerability scan results."""
        vuln = [t for t in result.test_results if t.is_vulnerable]
        if not vuln:
            return f"✅ Web Vulnerabilities: {result.total_tests} Tests, keine Schwachstellen."
        return (
            f"⚠️ Web Vulnerabilities: {result.vulnerabilities_found}/{result.total_tests} "
            f"Schwachstellen gefunden (Höchste: {result.highest_severity.value})"
        )
