"""
REDSWARM â€” Exploit Agent Wrapper
==================================
HTTP-Service der den bestehenden ExploitAgent wrapped.
Entwickelt gezielte Angriffs-Payloads basierend auf Recon-Intel.
"""

import os
import sys
import asyncio
import logging

PROJECT_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
sys.path.insert(0, PROJECT_ROOT)
sys.path.insert(0, os.path.join(PROJECT_ROOT, "agents"))

from base_wrapper import create_agent_app, MissionPayload, send_update, get_mission_findings

logger = logging.getLogger("RedSwarm.Exploit")

AGENT_ID   = "exploit-v1"
AGENT_PORT = int(os.getenv("AGENT_PORT", "8101"))

os.environ.setdefault("AGENT_BASE_URL", f"http://agent-exploit:{AGENT_PORT}")


async def run_exploit_agent(blackboard, payload: MissionPayload, bridge):
    """
    Startet den ExploitAgent mit dem lokalen Blackboard.
    Holt zuerst Recon-Findings vom Backend und speist sie ins Blackboard ein.
    """
    from swarm.agents.exploit_agent import ExploitAgent
    from config import AppConfig

    config = AppConfig()
    agent = ExploitAgent(
        name="exploit",
        blackboard=blackboard,
        config=config,
    )

    await send_update(
        payload.update_url, payload.api_key, AGENT_ID,
        "progress", {"percent": 5, "current_task": "Lade Recon-Intel vom Backend..."}
    )

    # Recon-Findings vom Backend holen und ins lokale Blackboard einspeisen
    if payload.findings_url:
        findings = await get_mission_findings(payload.findings_url)
        intel_count = 0
        for f in findings:
            if f.get("source_section") == "intel" or f.get("attack_vector"):
                blackboard.post_intel(
                    author="recon",
                    title=f.get("title", "Imported Finding"),
                    content=f.get("description", ""),
                    kill_chain_phase=f.get("kill_chain_phase", 1),
                    attack_vector=f.get("attack_vector", ""),
                    confidence=f.get("confidence", 0.5),
                    priority={"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "INFO": 4}.get(
                        f.get("severity", "MEDIUM"), 2
                    ),
                    target_system=payload.target_url,
                    tags=f.get("tags", []),
                    metadata=f,
                )
                intel_count += 1

        await send_update(
            payload.update_url, payload.api_key, AGENT_ID,
            "log", {"level": "info", "message": f"{intel_count} Intel-EintrÃ¤ge vom Recon importiert"}
        )

    # Falls keine Intel vorhanden: eigene Exploit-Tasks erstellen
    if not blackboard.read(section="intel", limit=1):
        vectors = payload.attack_vectors or ["prompt_injection", "jailbreak", "data_exfiltration"]
        for vector in vectors:
            blackboard.create_task(
                title=f"exploit: {vector} @ {payload.target_url}",
                content=f"Entwickle {vector} Payloads fÃ¼r {payload.target_url}",
                author="c4",
                assigned_to="exploit",
                priority=2,
                kill_chain_phase=2,
                attack_vector=vector,
                target_system=payload.target_url,
                metadata={"scan_depth": payload.scan_depth},
            )

    await send_update(
        payload.update_url, payload.api_key, AGENT_ID,
        "progress", {"percent": 15, "current_task": "Payload-Entwicklung gestartet"}
    )

    agent_task = asyncio.create_task(agent.start())

    timeout = {"low": 300, "medium": 600, "high": 900, "critical": 1800}.get(payload.intensity, 600)

    try:
        for elapsed in range(0, timeout, 5):
            await asyncio.sleep(5)

            pending = blackboard.get_pending_tasks("exploit")
            in_progress = blackboard.read(section="tasks", task_status="in_progress")
            exploit_in_progress = [t for t in in_progress if getattr(t, 'assigned_to', '') == 'exploit']

            if not pending and not exploit_in_progress and elapsed > 30:
                logger.info(f"[{AGENT_ID}] Exploit-Entwicklung abgeschlossen nach {elapsed}s")
                break
    except asyncio.CancelledError:
        pass
    finally:
        await agent.stop()
        agent_task.cancel()


app = create_agent_app(
    agent_id=AGENT_ID,
    agent_name="Exploit Agent",
    agent_desc="Entwickelt gezielte Angriffs-Payloads: Prompt Injection, RAG Poisoning, Tool Shadowing, KB-Optimierung",
    agent_icon="ðŸ’‰",
    capabilities=[
        "payload-development",
        "prompt-injection-crafting",
        "rag-poisoning",
        "tool-shadowing",
        "kb-optimization",
        "adaptive-mutation",
    ],
    target_types=["chatbot", "api", "agent", "rag", "webapp"],
    agent_factory=run_exploit_agent,
    port=AGENT_PORT,
)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=AGENT_PORT)
